# 正则

## 元字符

`.`：除换行符以外的任意字符
`\d`：数字, 等价于字符组[0-9]
`\D`：任意非数字字符, 等价于[^0-9]
`\w`：字母, 数字, 下划线
`\W`：除字母,数字,下划线之外的任意字符
`\s`：任意的空白符，包括空格、制表符、换行等
`\S`：非空白字符
`\b`：单词开始或结束的位置
`\B`：非单词开始或结束的位置
`^`：行首
`$`：行尾

## 重复限定符

`*`：x >= 0
`+`：x >= 1
`?`：x == 0 or x == 1
`{n}`：x == n
`{n,}`：x >= n
`{n,m}`：n <= x <= m

## 字符组

`[abc+.?]`：a/b/c 加号/点号/问号

## 多选

`(a|b|c)`：a/b/c

## 转义

`\\`: 匹配 `\`

## 排除

`[^x]`：除 x 以外的任意字符

## 修饰符

`g`：全文查找
`i`：忽略大小写

## 贪婪模式

- 贪婪匹配：正则表达式一般趋向于最大长度匹配
- 非贪婪匹配：匹配到结果就好，匹配尽量少字符

> 默认是贪婪匹配，在量词后加一个 `?`，就是非贪婪模式

## 反向引用

```js
const url = 'www.google.com';
const reg = /([a-z]+)\.\1/;
console.log(url.replace(reg, '$1')); // www.google.com

'abcaabcabbcabcc'.match(/([abc])\1/g); // ["aa", "bb", "cc"]
```

## 零宽断言

- `(?:pattern)`：非捕获性分组, 匹配 pattern 的位置, 但不捕获匹配结果.也就是说不创建反向引用, 就好像没有括号一样。 'abcd(?:e)'匹配’abcde
- `(?=pattern)`：顺序肯定环视，匹配后面是 pattern 的位置，不捕获匹配结果。'Windows(?=2000)'匹配 "Windows2000" 中的 "Windows"; 不匹配 "Windows3.1" 中的 "Windows"
- `(?!pattern)`：顺序否定环视，匹配后面不是 pattern 的位置，不捕获匹配结果。'Windows(?!2000)'匹配 "Windows3.1" 中的 "Windows"; 不匹配 "Windows2000" 中的 "Windows"
- `(?<=pattern)`：逆序肯定环视，匹配前面是 pattern 的位置，不捕获匹配结果。'(?<=Office)2000'’'匹配 "Office2000" 中的 "2000"; 不匹配 "Windows2000" 中的 "2000"
- `(?<!pattern)`：逆序否定环视，匹配前面不是 pattern 的位置，不捕获匹配结果。'(?<!Office)2000'’'匹配 "Windows2000" 中的 "2000"; 不匹配 "Office2000” 中的 "2000"

```js
const str = '123abc789';
let s = '';
// 没有使用环视，abc直接被替换
s = str.replace(/abc/, 456);
console.log(s); //123456789

// 使用了顺序肯定环视,捕获到了a前面的位置,所以abc没有被替换,只是将3替换成了3456
s = str.replace(/3(?=abc)/, 3456);
console.log(s); //123456abc789

// 使用了顺序否定环视，由于3后面跟着abc，不满意条件，故捕获失败,所以原字符串没有被替换
s = str.replace(/3(?!abc)/, 3456);
console.log(s); //123abc789
```
