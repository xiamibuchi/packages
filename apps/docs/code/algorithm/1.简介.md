# 简介

## 时间复杂度和空间复杂度

时间复杂度：反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。

没有循环语句，记作 O(1)，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模 n 呈线性增大关系，记作 O（n），也叫线性阶。
常见的时间复杂度有：

O(1): Constant Complexity: Constant 常数复杂度
O(log n): Logarithmic Complexity: 对数复杂度
O(n): Linear Complexity: 线性时间复杂度
O(n^2): N square Complexity 平⽅方
O(n^3): N square Complexity ⽴立⽅方
O(2^n): Exponential Growth 指数
O(n!): Factorial 阶乘

空间复杂度：运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。

一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。

在描述算法复杂度时,经常用到 o(1), o(n), o(logn), o(nlogn)来表示对应算法的时间复杂度, 这里进行归纳一下它们代表的含义:
这是算法的时空复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。
O 后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系。其中的 n 代表输入数据的量。
比如时间复杂度为 O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。
再比如时间复杂度 O(n^2)，就代表数据量增大 n 倍时，耗时增大 n 的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的 O(n^2)的算法，对 n 个数排序，需要扫描 n×n 次。
再比如 O(logn)，当数据增大 n 倍时，耗时增大 logn 倍（这里的 log 是以 2 为底的，比如，当数据增大 256 倍时，耗时只增大 8 倍，是比线性还要低的时间复杂度）。二分查找就是 O(logn)的算法，每找一次排除一半的可能，256 个数据中查找只要找 8 次就可以找到目标。
O(nlogn)同理，就是 n 乘以 logn，当数据增大 256 倍时，耗时增大 256\*8=2048 倍。这个复杂度高于线性低于平方。归并排序就是 O(nlogn)的时间复杂度。
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的 O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）

## 逻辑结构

逻辑结构就是数据之间的关系，逻辑结构大概统一的可以分成两种：线性结构、非线性结构。
线性结构：是一个有序数据元素的集合。 其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。
常用的线性结构有: 栈，队列，链表，线性表。
—非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。
常见的非线性结构有 二维数组，树等。

## 存储结构

逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。常见的存储结构有顺序存储、链式存储、索引存储以及散列存储。
例如：数组在内存中的位置是连续的，它就属于顺序存储；链表是主动建立数据间的关联关系的，在内存中却不一定是连续的，它属于链式存储；还有顺序和逻辑上都不存在顺序关系，但是你可以通过一定的方式去放问它的哈希表，数据散列存储。

## 数据结构

### 二叉树

树是用来模拟具有树状结构性质的数据集合。根据它的特性可以分为非常多的种类，对于我们来讲，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。

二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。

- 前序遍历：根节点 -> 同级先左后右
- 中序遍历：左 -> 根 -> 右
- 后序遍历：左 -> 右 -> 根

### 链表

用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。

- 需要遍历才能查询到元素，查询慢
- 插入元素只需断开连接重新赋值，插入快

单向链表和双向链表

链表这种存储方式最大缺点就是容易出现断链

### 栈

栈是一种操作受限的线性表只允许从一端插入和删除数据，后进先出。

## 排序

### 快速排序

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。。。

- 选择一个基准元素 target（一般选择第一个数）
- 将比 target 小的元素移动到数组左边，比 target 大的元素移动到数组右边
- 分别对 target 左侧和右侧的元素进行快速排序

递归：

```js
function quickSort(array) {
  if (array.length < 2) {
    return array;
  }
  const target = array[0];
  const left = [];
  const right = [];
  for (let i = 1; i < array.length; i++) {
    if (array[i] < target) {
      left.push(array[i]);
    } else {
      right.push(array[i]);
    }
  }
  return quickSort(left).concat([target], quickSort(right));
}
```

```js
function quickSort(array, start, end) {
  if (end - start < 1) {
    return;
  }
  const target = array[start];
  let l = start;
  let r = end;
  while (l < r) {
    while (l < r && array[r] >= target) {
      r--;
    }
    array[l] = array[r];
    while (l < r && array[l] < target) {
      l++;
    }
    array[r] = array[l];
  }
  array[l] = target;
  quickSort(array, start, l - 1);
  quickSort(array, l + 1, end);
  return array;
}
```

### 冒泡排序
