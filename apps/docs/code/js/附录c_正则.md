# 正则表达式(RegExp)

### 正则表达式

### RegExp 构造函数

1. 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。

   1. ```js
      const regex = new regExp('xyz', 'i');
      //等价于
      const regex = /xyz/i;
      ```

2. 参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝。

   ```js
   const regex = new RegExp(/xyz/i);
   // 等价于
   const regex = /xyz/i;
   ```

   但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。

   ```js
   const regex = new RegExp(/xyz/, 'i');
   // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
   ```

   ES6 改变了这种行为。如果`RegExp`构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。

   ```
   new RegExp(/abc/ig, 'i').flags
   // "i"

   ```

   上面代码中，原有正则对象的修饰符是`ig`，它会被第二个参数`i`覆盖。

## 正则是啥？

正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"）。

## 元字符

\是转移字符，其后面的字符会代表不同的意思，转移字符主要有三个作用：

第一种，是为了匹配不方便显示的特殊字符，比如换行，tab 符号等

第二种，正则中预先定义了一些代表特殊意义的字符，比如\w 等

第三种，在正则中某些字符有特殊含义(比如下面说到的)，转义字符可以让其显示自身的含义

下面是常用转义字符列表：

### 常见元字符

- \d 匹配数字（0~9） '\d'匹配 8,不匹配 12
- \D 匹配非数字 '\D'匹配 c,不匹配 3
- \w 匹配一个字母或数字 '\w\w' 匹配 A3,不匹配@3
- \W 匹配非单词字符 '\W'匹配@,不匹配 c
- \s 匹配空白字符 '\d\s\d'匹配 3 d,不匹配 abc
- \S 匹配非空字符 '\S\S\S'匹配 A#4,不匹配 3 d
- \b 匹配单词边界
- \B 匹配非单词边界
- \n 匹配换行符
- \r 匹配回车符
- \t 匹配制表符(tab)
- . 匹配任意字符
- | 表示'或'
- () 优先级最低，表示分组

### 字符类元字符

- ^ 表示匹配必须由起始开始
- $ 表示匹配必须由末尾结束
- [] 表达字符的位置，里面是可能出现的字符
  - [^] 是非的意思
  - [a-z][1-9]表示范围

### 量词类元字符

- `*`表示能够出现 0 次或者更多次，x>=0;
- `+`表示能够出现 1 次或者多次，x>=1
- `?`表示能够出现 0 次或者 1 次，x=0 或者 x=1
- `{n}`表示能够出现 n 次
- `{n,}`表示能够出现 n 次或者 n 次以上
- `{n,m}`表示能够出现 n-m 次

来看一个复杂的例子：\d{3}\s+\d{3,8}。我们来从左到右解读一下：

- \d{3}表示匹配 3 个数字，例如'010'；
- \s 可以匹配一个空格（也包括 Tab 等空白符），所以\s+表示至少有一个空格，例如匹配' '，'\t\t'等；
- \d{3,8}表示 3-8 个数字，例如'1234567'。

要做更精确地匹配，可以用`[]`表示范围，比如：

- `[0-9a-zA-Z\_]`：匹配一个数字、字母或者下划线；
- `[0-9a-zA-Z\_]+`：匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等；
- `[a-zA-Z\_\$][0-9a-zA-Z\_\$]+`：匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串
- `[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}`：精确地限制了变量的长度是 1-20 个字符（前面 1 个字符+后面最多 19 个字符）。
- `A|B`：可以匹配 A 或 B
- `^`：行的开头，`^\d`表示必须以数字开头。
- `$`：表示行的结束，`\d$`表示必须以数字结束。

### JavaScript 中的 RegExp

JavaScript 有两种方式创建一个正则表达式：

- `/正则表达式/`
- `new RegExp('正则表达式')`

注意：`new RegExp`方法中的“正则表达式”需要注意字符串的转义，如：

`/ABC\-001/`和`new RegExp('ABC\\-001')`实际上是相同的

RegExp 对象的 test()方法用于测试给定的字符串是否符合条件：

```js
const re = /^\d{3}-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
re.test('010 12345'); // false
```

#### 切分字符串

`split()`方法：把一个字符串分割成字符串数组。

`stringObject.split(separator,howmany)`

separator：必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。

howmany：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。

注：如果把空字符串 ("") 用作 +separator+，那么 stringObject 中的每个字符之间都会被分割。

#### 分组

`exec()` 方法：检索字符串中的正则表达式的匹配。或者在没有匹配项的情况下返回 null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。其中，index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。

`RegExpObject.exec(string)`

如果 `exec()` 找到了匹配的文本，会返回一个 Array，第一个元素始终是原始字符串本身，后面的字符串表示匹配成功的子串。。否则，返回 null。如：

```js
const re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

#### 贪婪匹配

正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。如：

```js
const re = /^(\d+)(0+)$/;
re.exec('102300'); // ['102300', '102300', '']
```

由于`\d+`采用贪婪匹配，直接把后面的 0 全部匹配了，结果 0+只能匹配空字符串了。

必须让`\d+`采用非贪婪匹配（也就是尽可能少匹配），才能把后面的 0 匹配出来，加个?就可以让\d+采用非贪婪匹配：

```js
const re = /^(\d+?)(0+)$/;
re.exec('102300'); // ['102300', '1023', '00']
```

#### 全局搜索

JavaScript 的正则表达式还有几个特殊的标志，最常用的是 g，表示全局匹配：

```js
const r1 = /test/g;
// 等价于:
const r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行 exec()方法来搜索一个匹配的字符串。当我们指定 g 标志后，每次运行 exec()，正则表达式本身会更新 lastIndex 属性，表示上次匹配到的最后索引：

```js
const s = 'JavaScript, VBScript, JScript and ECMAScript';
const re = /[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

全局匹配类似搜索，因此不能使用`/^...$/`，那样只会最多匹配一次。

_正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。_

## 字符集和

有时我们需要匹配一类字符，字符集可以实现这个功能，字符集的语法用[]分隔，下面的代码能够匹配 a 或 b 或 c

```
[abc]
```

如果要表示字符很多，可以使用-表示一个范围内的字符，下面两个功能相同

```
[0123456789]
[0-9]
```

在前面添加^，可表示非的意思，下面的代码能够匹配 abc 之外的任意字符

```
[^abc]
```

其实正则还内置了一些字符集，在上面的转义字符有提到，下面给出内置字符集对应的自定义字符集

- . 匹配除了换行符（\n）以外的任意一个字符 = [^\n]
- \w = [0-9a-Z_]
- \W = [^0-9a-Z_]
- \s = [ \t\n\v]
- \S = [^ \t\n\v]
- \d = [0-9]
- \D = [^0-9]

## 量词

如果我们有三个苹果，我们可以说自己有个 3 个苹果，也可以说有一个苹果，一个苹果，一个苹果，每种语言都有量词的概念

如果需要匹配多次某个字符，正则也提供了量词的功能，正则中的量词有多个，如?、+、\*、{n}、{m,n}、{m,}

{n}匹配 n 次，比如 a{2}，匹配 aa

{m, n}匹配 m-n 次，优先匹配 n 次，比如 a{1,3}，可以匹配 aaa、aa、a

{m,}匹配 m-∞ 次，优先匹配 ∞ 次，比如 a{1,}，可以匹配 aaaa...

?匹配 0 次或 1 次，优先匹配 1 次，相当于{0,1}

+匹配 1-n 次，优先匹配 n 次，相当于{1,}

\*匹配 0-n 次，优先匹配 n 次，相当于{0,}

正则默认和人心一样是贪婪的，也就是常说的贪婪模式，凡是表示范围的量词，都优先匹配上限而不是下限

```
a{1, 3} // 匹配字符串'aaa'的话，会匹配aaa而不是a
```

有时候这不是我们想要的结果，可以在量词后面加上?，就可以开启非贪婪模式

```
a{1, 3}? // 匹配字符串'aaa'的话，会匹配a而不是aaa
```

## 字符边界

有时我们会有边界的匹配要求，比如已 xxx 开头，已 xxx 结尾

^在[]外表示匹配开头的意思

```
^abc // 可以匹配abc，但是不能匹配aabc
```

$表示匹配结尾的意思

```
abc$ // 可以匹配abc，但是不能匹配abcc
```

上面提到的\b 表示单词的边界

```
abc\b // 可以匹配 abc ，但是不能匹配 abcc
```

## 选择表达式

有时我们想匹配 x 或者 y，如果 x 和 y 是单个字符，可以使用字符集，[abc]可以匹配 a 或 b 或 c，如果 x 和 y 是多个字符，字符集就无能为力了，此时就要用到分组

正则中用|来表示分组，a|b 表示匹配 a 或者 b 的意思

```
123|456|789 // 匹配 123 或 456 或 789
```

## 分组与引用

分组是正则中非常强大的一个功能，可以让上面提到的量词作用于一组字符，而非单个字符，分组的语法是圆括号包裹(xxx)

```
(abc){2} // 匹配abcabc
```

分组不能放在[]中，分组中还可以使用选择表达式

```
(123|456){2} // 匹配 123123、456456、123456、456123
```

和分组相关的概念还有一个捕获分组和非捕获分组，分组默认都是捕获的，在分组的(后面添加?:可以让分组变为非捕获分组，非捕获分组可以提高性能和简化逻辑

```
'123'.match(/(?123)/) // 返回 ['123']
'123'.match(/(123)/)  // 返回 ['123', '123']
```

和分组相关的另一个概念是引用，比如在匹配 html 标签时，通常希望<xxx></xxx>后面的 xxx 能够和前面保持一致

引用的语法是\数字，数字代表引用前面第几个捕获分组，注意非捕获分组不能被引用

```
<([a-z]+)><\/\1> // 可以匹配 `<span></span>` 或 `<div></div>`等
```

## 预搜索

如果你想匹配 xxx 前不能是 yyy，或者 xxx 后不能是 yyy，那就要用到预搜索

js 只支持先行预搜索，也就是 xxx 前面必须是 yyy，或者 xxx 前面不能是 yyy

```
(?=1)2 // 可以匹配12，不能匹配22
(?!1)2 // 可有匹配22，不能匹配12
```

## 修饰符

默认正则是区分大小写，这可能并不是我们想要的，正则提供了修饰符的功能，修复的语法如下

```
/xxx/gi // 最后面的g和i就是两个修饰符
```

g 正则遇到第一个匹配的字符就会结束，加上全局修复符，可以让其匹配到结束

i 正则默认是区分大小写的，i 可以忽略大小写

m 正则默认遇到换行符就结束了，不能匹配多行文本，m 可以让其匹配多行文本

有时我们会遇到特别负责的正则，有时候可能不太只管，下面推荐一个图形化展示的[工具](https://link.zhihu.com/?target=https%3A//jex.im/regulex)，我们把涉及到的语法罗列一下

```
/^[a-z]*[^\d]{1,10}?(aaa|bbb)(?:ccc)$/
```

在 js 中创建正则有两种办法，字面量和 new，和创建其他类型变量一样

```
var reg = /abc/g // 字面量
var reg = new RegExp('abc', 'g') // new方式，意思和上面一样
```

js 中用到正则的地方有两个入口，正则的 api 和字符串的 api，`RegExp#test`等于`RegExp.prototype.test`

- RegExp#test
- RegExp#exec
- String#search
- String#match
- String#split
- String#replace

## RegExp#test

每个正则实例都有 test 方法，test 的参数是字符串，返回值是布尔值，表示当前正则是否能匹配指定的字符串

```
/abc/.test('abc') // true
/abc/.test('abd') // false
```

## RegExp#exec

exec 使用方法和 test 一样，只是返回值并不是布尔值，而是返回匹配的结果

匹配成功返回一个数组，数组第一项是匹配结果，后面一次是捕获的分组

```
/abc(d)/.exec('abcd') // ["abcd", "d", index: 0, input: "abcd"]
```

此数组还有另外两个参数，input 是输入的字符串，index 表示匹配成功的序列在输入字符串中的索引位置

如果有全局参数(g)，第二次匹配时将从上次匹配结束时继续

```
var r1 = /ab/
r1.exec('ababab') // ['ab', index: 0]
r1.exec('ababab') // ['ab', index: 0]

var r2 = /ab/g
r2.exec('ababab') // ['ab', index: 0]
r2.exec('ababab') // ['ab', index: 2]
r2.exec('ababab') // ['ab', index: 4]
```

这一特性可以被用于循环匹配，比如统计字符串中 abc 的次数

```
var reg = /abc/g
var str = 'abcabcabcabcabc'
var num = 0;
var match = null;
while((match = reg.exec(str)) !== null) {
    num++
}
console.log(num) // 5
```

如果匹配失败则返回 null

```
/abc(d)/.exec('abc') // null
```

## String#search

search 方法返回匹配成功位置的索引，参数是字符串或正则，结果是索引

```
'abc'.search(/abc/) // 0
'abc'.search(/c/) // 2
```

如果匹配失败则返回-1

```
'abc'.search(/d/) // -1

'abc'.search(/d/) !== -1 // false 转换为布尔值
```

## String#match

match 方法也会返回匹配的结果，匹配结果和 exec 类似

```
'abc'.match(/abc/) // ['abc', index: 0, input: abc]
'abc'.match(/abd/) // null
```

如果有全局参数(g)，match 会返回所有的结果，并且没有 index 和 input 属性

```
'abcabcabc'.match(/abc/g) // ['abc', 'abc', 'abc']
```

## String#split

字符串的 split 方法，可以用指定符号分隔字符串，并返回数据

```
'a,b,c'.split(',') // [a, b, c]
```

其参数也可以使一个正则，如果分隔符有多个时，就必须使用正则

```
'a,b.c'.split(/,|\./) // [a, b, c]
```

## String#replace

字符串的 replace 方法，可以将字符串的匹配字符，替换成另外的指定字符

```
'abc'.replace('a', 'b') // 'bbc'
```

其第一个参数可以是正则表达式，如果想全局替换需添加全局参数

```
'abc'.replace(/[abc]/, 'y') // ybc
'abc'.replace(/[abc]/g, 'y') // yyy 全局替换
```

在第二个参数中，也可以引用前面匹配的结果

```
'abc'.replace(/a/, '$&b') // abbc $& 引用前面的匹配字符
'abc'.replace(/(a)b/, '$1a') // aac &n 引用前面匹配字符的分组
'abc'.replace(/b/, '$\'') // aac $` 引用匹配字符前面的字符
'abc'.replace(/b/, "$'") // acc $' 引用匹配字符后面的字符
```

replace 的第二个参数也可以是函数，其第一个参数是匹配内容，后面的参数是匹配的分组

```
'abc'.replace(/\w/g, function (match, $1, $2) {
    return match + '-'
})
// a-b-c-
```

## RegExp

RegExp 是一个全局函数，可以用来创建动态正则，其自身也有一些属性

- $\_
- $n
- input
- length
- lastMatch

来个例子

```
/a(b)/.exec('abc') // ["ab", "b", index: 0, input: "abc"]

RegExp.$_ // abc 上一次匹配的字符串
RegExp.$1 // b 上一次匹配的捕获分组
RegExp.input // abc 上一次匹配的字符串
RegExp.lastMatch // ab 上一次匹配成功的字符
RegExp.length // 2 上一次匹配的数组长度
```

## 实例属性

正则表达式的实例上也有一些属性

- flags
- ignoreCase
- global
- multiline
- source
- lastIndex

还是看例子

```
var r = /abc/igm;

r.flags // igm
r.ignoreCase // true
r.global // true
r.multiline // true
r.source // abc
```

lastIndex 比较有意思，表示上次匹配成功的是的索引

```
var r = /abc/igm;
r.exec('abcabcabc')
r.lastIndex // 3

r.exec('abcabcabc')
r.lastIndex // 6
```

可以更改 lastIndex 让其重新开始

```
var r = /abc/igm;
r.exec('abcabcabc') // ["abc", index: 0]

r.exec('abcabcabc') // ["abc", index: 3]
r.lastIndex = 0
r.exec('abcabcabc') // ["abc", index: 0]
```

## 实战实例

来几个常用的例子

```
/(?:0\d{2,3}-)?\d{7}/ // 电话号 010-xxx xxx

/^1[378]\d{9}$/ // 手机号 13xxx 17xxx 18xxx

/^[0-9a-zA-Z_]+@[0-9a-zA-Z]+\.[z-z]+$/ // 邮箱
```

去除字符串前后空白

```
str = str.replace(/^\s*|\s*$/g, '')
```

## 总结

到这里你已经学会了正则的语法，并且学会了在 js 中使用正则的方法，接下来快去实战吧，要想学会正则必须多加练习，正所谓拳不离手曲不离口吗

在[下一篇文章](http://yanhaijing.com/javascript/2017/11/29/regexp-principle/)中，准备讲一讲正则的实现原理，难度略大 o(╯□╰)o
